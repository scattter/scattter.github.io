# 工厂模式缓存函数调用

## 背景

这两天工作上遇到一个接口异常调用的问题, 有用户在半个小时内调用了17, 000次. 这个接口它本身是一个轮询接口, 但是正常情况下是3s调用一次, 因此这个数据是极其不正常的. 后续通过埋点以及测试同学测试, 终于找到了问题的原因: 组件多次创建, 一个页面上有多个实例(业务上是购买弹窗, 后以购买弹窗代替), 导致出现了异常轮询.



## 问题定位

根据测试的流程定位后发现有三个可以优化的点, 具体为:

- 单页面购买弹窗可以唤起多次

- 当页面标签不可见时依然会触发轮询

- 多次唤起弹窗, 弹窗的前置逻辑会触发多次



这些问题可以在调用处进行解决, 如加一些防抖等, 但是更好的方法是从源头开始解决, 因此有了下述的相应优化.



## 问题优化

| 问题                                   | 解决方法                                                     |
| -------------------------------------- | ------------------------------------------------------------ |
| 单页面购买弹窗可以唤起多次             | 在真正构建弹窗的函数作用域内定义当前弹窗数组, 同时定义需要限制为唯一弹窗的组件, 如果当前弹窗数组中存在该弹窗组件名, 不新建弹窗![image2023-12-6_13-50-3](https://cdn.jsdelivr.net/gh/scattter/blogweb/images/image2023-12-6_13-50-3.png) |
| 当页面标签不可见时依然会触发轮询       | 通过监听标签页的隐藏与失焦失焦来进行处理![image-20231206195457360](https://cdn.jsdelivr.net/gh/scattter/blogweb/images/image-20231206195457360.png) |
| 多次唤起弹窗, 弹窗的前置逻辑会触发多次 | 使用工厂函数来做接口调用的缓存, 即外部调用多次, 但是依然是一个实例.这里做了一层包装, 抽出了一个公共的promise缓存工厂, 生产者决定生产具体的工厂函数.![image-20231206195758010](https://cdn.jsdelivr.net/gh/scattter/blogweb/images/image-20231206195758010.png) |



## 总结

上面三个优化中有两个都用到了闭包的概念, 即函数的返回是一个函数, 返回的函数共用闭包里面的变量进而实现一些缓存, 属于是深刻加深了我对闭包的理解. 另外一个是使用工厂函数做函数缓存是没想到的, 之前学工厂函数的时候只知道能封一些公共属性这些, 很多设计模式还是要在具体业务中使用了才能更深入的了解它.